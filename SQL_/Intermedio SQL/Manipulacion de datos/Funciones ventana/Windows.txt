Al trabajar con funciones de agregacion se requiere agrupar los resultados, si no se agrupan NO se puede comparar los valores agregados con datos no agregados. 
Para evitar esta limitacion existen las funciones de ventana. 

## Funciones Ventana ##
Son una clase de funciones que realizan calculos en un conjunto de resultados que ya se ha generado denomindo "Ventana" 
- Usar funciones de ventana para realizar calculos agregados sin tener que agrupar datos (similar a la subconsulta en SELECT)
- Calcular informacion como totales acomulados, clasificaciones y promedios moviles 
-- > Lo que las diferencia de las subconsultas SELECT son las diferentes declaraciones que se pueden agregar dentro de la funciones OVER() 

- como funciona, esta clausula le dice a SQL que "Pase este valor agregado sobre este conjunto de resultados existente" --> el resultado es 
similar a una subconsulta en SELECT mas simple y un tiempo de procesamiento mas rapido 

Ejemplo: cuantos goles son en promedio anotados en cada partido de la temporada 2011/2012 y cual es el promedio total ? 

SELECT
    date,
    (home_goal + away_goal) AS goals, 
    AVG(home_goal + away_goal) OVER() AS overall_avg
FROM
    match 
WHERE 
    season = '2011/2012';

#### RANK ####
crea una numeracion de columnas del conjunto de datos de mayor a menor, o viceversa, en funcion de la columna que se especifique 

Ejemplo: cual es el rango de partidos segun el numero de goles marcados? 

SELECT
    date,
    (home_goal + away_goal) AS goals, 
    RANK() OVER(ORDER BY home_goal + away_goal DESC) AS goals_rank    ---> creamos una nueva columna con RANK, 
    esto ordena de manera predeterminada de menor a mayor (usamos DESC para invertir)
FROM 
    match 
WHERE 
    season = '2011/2012';


---> consideraciones: las funciones ventanas se procesan DESPUES de la consulta completa, excepto la instrucion ORDER BY FINAL
--> usa el conjunto de rersultados para calcular la informacion, en lugar de la base de datos directamente 
--> Disponibles en MySQL, PostgreSQL, Oracle pero NO en SQLite 


Ejemplos plataforma: Selecciona el ID del partido, el nombre del país, la temporada, los goles en casa y los goles fuera en las tablas match y 
country. Completa la consulta que calcula el número medio de goles marcados en total y luego incluye el valor agregado en cada fila utilizando 
una función de ventana.

 SELECT 
	m.id, 
    c.name AS country, 
    m.season,
	m.home_goal,
	m.away_goal,
	AVG(m.home_goal + m.away_goal) OVER() AS overall_avg
FROM 
    match AS m
LEFT JOIN country AS c 
    ON m.country_id = c.id;


Ejemplo OVER + RANK:
SELECT 
	l.name AS league,
    AVG(m.home_goal + m.away_goal) AS avg_goals,
    RANK() OVER(ORDER BY AVG(m.home_goal + m.away_goal)) AS league_rank
FROM 
    league AS l
LEFT JOIN match AS m 
    ON l.id = m.country_id
WHERE 
    m.season = '2011/2012'
GROUP BY 
    l.name
ORDER BY 
    league_rank;


### Ventanas deslizantes Sliding windows ###

Las funciones ventana tambien se pueden usar para calcular informacion que cambia con cada fila subsiguiente en un conjunto de datos. 
Calculos relativos a la fila actual de un conjunto de datos. Un calculo de ventana deslizante puede dividirse en una o mas columnas, 
al igual que las ventanas NO deslizantes. 

Palabras clave de las Sliding windows son utilizadas para especificar LOS DATOS a utilizar en los calculos 

ROW_NUMBER() asigna un numero secuencial unico a cada fila dentro de la particion de datos comenzando por 1. ORDER BY ES OBLIGATORIO al usar ROW_NUMBER

RANGE BETWEEN - ROWS BETWEEN <start> AND <finish>
    PRECEDING - antes de la fila actual (antes de la declaracion se agrega cuantas filas se necesitan)
    FOLLOWING - despues de la fila actual (antes de la declaracion se agrega cuantas filas se necesitan)
    UNBOUNDED PRECEDING(Precedente sin limites) - agregar cada fila desde el principio
    UNBOUNDED FOLLOWING(Siguiente sin limites) - agregar cada fila desde el final 
    CURRENT ROW - hacer los calculos en la fila actual

Ejemplo: calcular la suma de goles marcados localmente por Man city durante la temporada 2011/2012

SELECT
	date,
	home_goal,
	away_goal,
    SUM(home_goal)
        OVER(ORDER BY date ROWS BETWEEN
            UNBOUNDED PRECEDING AND CURRENT ROW) AS runnunig_total
FROM
    match 
WHERE
    hometeam_id = 8456 AND season ='2011/2012';

Agregar una columna con el promedio de goles  del equipo FC Utrecht 

SELECT 
	date,
	home_goal,
	away_goal,
    SUM(home_goal) OVER(ORDER BY date
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,
    AVG(home_goal) OVER(ORDER BY date 
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg
FROM match
WHERE 
	hometeam_id = 9908 
	AND season = '2011/2012';

Calcular lo mismo que la anterior solo que se calcula de la fila actual a la mas vieja y de forma descendente 

SELECT 
	date,
    home_goal,
    away_goal,
    SUM(home_goal) OVER(ORDER BY date DESC
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS running_total,
    AVG(home_goal) OVER(ORDER BY date DESC
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS running_avg
FROM 
    match
WHERE 
	awayteam_id = 9908 
    AND season = '2011/2012';

######### OBTENCION RELATIVA ########
Se llaman asi por que el valor obtenido es relativo a la fila actual 

LAG --> Devuelve el valor de n filas antes de la fila actual 
LEAD --> Devuelve el valor de N filas despues de la fila actual 

---- LEAD(X_columna, 1,2,3,4 depende cuantas filas queremos despues) OVER() -----

--> Cuando ya no hay filas que mostrar el siguiente registro sera NULL <---

####### Obtencion Absoluta ########
Lo que devuelven NO dependen de la fila actual 

FIRST_VALUE -> obtiene el primer valor de la tabla o particion 
LAST_VALUE -> obtiene el ultimo valor de la tabla o particion 

--- FIRST_VALUE(X_columna) OVER() --- 

--- LAST_VALUE(X_columna) OVER() ---

--> Cuando ya no hay filas que mostrar el siguiente registro sera NULL <---


####### FUNCIONES DE CLASIFICACION ####### 

- ROW_NUMBER() --> asigna un numero a las filas sin importar que sean las mismas, este siempre asignara numeros unicos tomando en cuenta 
    distintas caracteristicas de la fila, se pueden utilizar distintas particiones u ordenaciones para desempatar.
    ejemplo: 
            pizza       1 
            pizza       2
            hamburguesa 3
            taco        4
    SINTAXIS: ROW_NUMBER () OVER(PARTITION BY x_columna ORDER BY x_columna ASC/DESC) AS x_nombre --> Puede ir solo con el ORDER BY sin particion  

- RANK() --> Asigna el mimo numero a filas con valores identicos, se brinca al siguiente numero si esto sucede
    ejemplo: 
            pizza       1 
            pizza       1
            hamburguesa 3
            taco        4

    SINTAXIS: RANK () OVER(PARTITION BY x_columna ORDER BY x_columna ASC/DESC) AS x_nombre --> Puede ir solo con el ORDER BY sin particion  

- DENSE_RANK() --> Asigna el mimo numero a filas con valores identicos, PERO NO se brinca al siguiente numero
    ejemplo: 
            pizza       1 
            pizza       1
            hamburguesa 2
            taco        3
    
    SINTAXIS: DENSE_RANK () OVER(PARTITION BY x_columna ORDER BY x_columna ASC/DESC) AS x_nombre --> Puede ir solo con el ORDER BY sin particion  



########## PAGING ###############
Paging es dividir los datos en fragmentos aprox. iguales, es decir, divide la data en "grupos" que seran numerados con la funcion NTILE(n).

Un ejemplo son las API que devuelven los datos en "Paginas" para reducir el tamaño de los datos que se envian.

---> NTILE(n) es una funcion ventana que toma como entrada n_numeros de divisiones que se deseen y divide la data en "grupos"
aproximadamente igual cada uno. Con esta funcion se pueden hacer divisiones de Quartiles, con ella se puede saber la distribucion aprox de los datos 

Sintaxis: 
    SELECT
        NTILE(10) OVER() AS x_nombre
    FROM ....

Ejemplo si se tienen 67 libros y se quieren dividir en grupos de 15, no dara como resultado de 4 a 5 filas por grupo, estos seran numerados de 1 a 15.


